<!DOCTYPE html><html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content=""><title>树生 | 生存角色并不代表你的生活角色</title><link rel="stylesheet" type="text/css" href="/css/normalize.css"><link rel="stylesheet" type="text/css" href="/css/highlight.css"><link rel="stylesheet" type="text/css" href="/css/font.css"><link rel="stylesheet" type="text/css" href="/css/noise.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/font-awesome/4.5.0/css/font-awesome.min.css"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"></head><body><header class="wrapper header"><div class="container blog-title"><a class="title" id="logo" href="/.">树生</a><span class="subtitle">生存角色并不代表你的生活角色</span><label id="toggle-menu" for="menu" onclick><i class="fa fa-bars"></i></label></div><input id="menu" type="checkbox"><div class="container nav-items"><a class="sidebar-nav-item active" href="/">Home</a><a class="sidebar-nav-item" href="/archives">Archives</a></div></header><article class="wrapper"><div class="container entries" id="index-main"><div class="post-entry"><div class="post-desc"><div class="post-title"><a href="/2018/11/06/设计模式——桥接模式/">设计模式——桥接模式</a></div><div class="post-content"><blockquote>
<p><strong>定义</strong><br>桥接模式是将抽象部分与它的实现部分分离，使它们都可以独立地变化。它是一种对象结构型模式，又称为柄体(<code>Handle and Body</code>)模式或接口(<code>Interface</code>)模式。</p></div><div class="post-meta"><div class="post-tags"><a class="post-tag-link" href="/tags/设计模式/">设计模式</a></div><div class="post-time">2018-11-06</div></div></div></div><div class="post-entry"><div class="post-desc"><div class="post-title"><a href="/2018/11/06/Java自定义类加载器/">Java自定义类加载器</a></div><div class="post-content"><h3 id="自定义类加载器的应用场景"><a href="#自定义类加载器的应用场景" class="headerlink" title="自定义类加载器的应用场景"></a>自定义类加载器的应用场景</h3><ul>
<li><p><strong>加密</strong>：如果你不想自己的代码被反编译的话。（类加密后就不能再用ClassLoader进行加载了，这时需要自定义一个类加载器先对类进行解密，再加载）。</p></div><div class="post-meta"><div class="post-tags"><a class="post-tag-link" href="/tags/JVM/">JVM</a></div><div class="post-time">2018-11-06</div></div></div></div><div class="post-entry"><div class="post-desc"><div class="post-title"><a href="/2018/11/06/Java类加载源码阅读/">Java类加载源码阅读</a></div><div class="post-content"><h3 id="JVM自带加载器"><a href="#JVM自带加载器" class="headerlink" title="JVM自带加载器"></a>JVM自带加载器</h3><ul>
<li><strong>启动类加载器 BootStrap ClassLoader</strong>：最顶层的类加载器，负责加载 JAVA_HOME\lib 目录中的，或通过-Xbootclasspath参数指定路径中的，且被虚拟机认可（按文件名识别，如rt.jar）的类。可以通<code>System.getProperty(&quot;sun.boot.class.path&quot;)</code>查看加载的路径。</li>
<li><strong>扩展类加载器 Extention ClassLoader</strong>：主要加载目录<code>%JRE_HOME%\lib\ext</code>目录下的<code>jar</code>包和<code>class</code>文件，或通过java.ext.dirs系统变量指定路径中的类库。也可以通过<code>System.out.println(System.getProperty(&quot;java.ext.dirs&quot;))</code>查看加载类文件的路径。</li>
<li><strong>应用程序类加载器 Application ClassLoader</strong>：也叫做系统类加载器，可以通过<code>getSystemClassLoader()</code>获取，负责加载用户路径<code>classpath</code>上的类库。如果没有自定义类加载器，一般这个就是默认的类加载器。<br><br><br></li>
</ul>
<h3 id="类加载层次关系"><a href="#类加载层次关系" class="headerlink" title="类加载层次关系"></a>类加载层次关系</h3><p><img src="http://upload-images.jianshu.io/upload_images/3646846-59bf4d3e9f14fa08?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="类加载层次关系"></p></div><div class="post-meta"><div class="post-tags"><a class="post-tag-link" href="/tags/JVM/">JVM</a></div><div class="post-time">2018-11-06</div></div></div></div><div class="post-entry"><div class="post-desc"><div class="post-title"><a href="/2018/11/06/JVM类加载过程/">JVM类加载过程</a></div><div class="post-content"><p>JVM类加载分为5个过程：加载，验证，准备，解析，初始化，使用，卸载，如下图所示：<br><img src="https://upload-images.jianshu.io/upload_images/3646846-f27225423b01589d?imageMogr2/auto-orient/strip%7CimageView2/2/w/641/format/webp" alt="加载过程"></p></div><div class="post-meta"><div class="post-tags"><a class="post-tag-link" href="/tags/JVM/">JVM</a></div><div class="post-time">2018-11-06</div></div></div></div><div class="post-entry"><div class="post-desc"><div class="post-title"><a href="/2018/07/19/Flutter登录退出/">Flutter登录退出</a></div><div class="post-content"><h3 id="实现登录功能"><a href="#实现登录功能" class="headerlink" title="实现登录功能"></a>实现登录功能</h3><blockquote>
<p>为避免用户通过登录界面登录应用后按返回键仍能回到登录界面，我们需要在用户登录后创建一个新的路由栈</p></div><div class="post-meta"><div class="post-tags"><a class="post-tag-link" href="/tags/Flutter/">Flutter</a></div><div class="post-time">2018-07-19</div></div></div></div><div class="post-entry"><div class="post-desc"><div class="post-title"><a href="/2018/07/19/Flutter下拉刷新，上拉加载更多数据/">Flutter下拉刷新，上拉加载更多数据</a></div><div class="post-content"><h3 id="上拉加载更多"><a href="#上拉加载更多" class="headerlink" title="上拉加载更多"></a>上拉加载更多</h3><p><img src="https://user-gold-cdn.xitu.io/2018/7/9/1647b3e9601f88dd?w=270&h=480&f=gif&s=325692" width="25%"></p></div><div class="post-meta"><div class="post-tags"><a class="post-tag-link" href="/tags/Flutter/">Flutter</a></div><div class="post-time">2018-07-19</div></div></div></div><div class="post-entry"><div class="post-desc"><div class="post-title"><a href="/2018/07/19/设计模式——工厂方法模式/">设计模式——工厂方法模式</a></div><div class="post-content"><h2 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h2><blockquote>
<p><strong>定义</strong>：Define an interface for creating an object, but let subclasses decide which class instance.<br>Factory Method lets a class defer instantiation to subclasses.<br><br>（定义一个用于创建对象的接口 [这里的接口一词并不指Java中的接口构造，它可以是Java接口或抽象类] ，但是让子类决定去实例化哪个类。工厂方法将对象的实例化推迟到其子类。）</p></div><div class="post-meta"><div class="post-tags"><a class="post-tag-link" href="/tags/设计模式/">设计模式</a></div><div class="post-time">2018-07-19</div></div></div></div><div class="post-entry"><div class="post-desc"><div class="post-title"><a href="/2018/07/19/设计模式——单例模式/">设计模式——单例模式</a></div><div class="post-content"><h3 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h3><blockquote>
<p><strong>定义</strong>：Ensure a class has only one instance, and provide a global point of access to it.<br><br> （确保一个类只有一个实例，并提供一个全局访问点来访问这个唯一实例。）</p></div><div class="post-meta"><div class="post-tags"><a class="post-tag-link" href="/tags/设计模式/">设计模式</a></div><div class="post-time">2018-07-19</div></div></div></div></div></article><div class="wrapper page-navigator-wrapper"></div><footer class="footer wrapper"><div class="social"><a href="https://github.com/https://github.com/leyan95" target="_blank"><i class="fa fa-github"></i></a><a href="https://github.com/leyan95" target="_blank"><i class="fa fa-rss"></i></a></div><div class="footer-content">© 2018 <a href="/" rel="nofollow">树生</a>. Powered by <a rel="nofollow" target="_blank" href="https://hexo.io">Hexo</a>. Theme <a target="_blank" href="https://github.com/lotabout/hexo-theme-noise">noise</a>.</div></footer><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.css"><script src="//cdn.bootcss.com/jquery/2.0.3/jquery.min.js"></script><script src="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.pack.js"></script><script>$(document).ready(function() {
  $(".fancybox").fancybox();
});
</script></body></html>